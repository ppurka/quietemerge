#!/bin/bash

        #-----------------------------------------------------------#
        #   This program is used to make emerge output pretty       #
        #   Version: 20091112                                       #
        #                                           -ppurka         #
        #-----------------------------------------------------------#

        #--------------------- License: GPL-3  ---------------------#
        # Copyright (C) 2009  ppurka _at_ gmail _dot_ com           #
        # This program comes with ABSOLUTELY NO WARRANTY;           #
        # This is free software, and you are welcome to redistribute#
        # it under certain conditions;                              #
        #                                                           #
        # For a brief summary of the license see the help text of   #
        # this program by executing:                                #
        # quietemerge --help                                        #
        #                                                           #
        # For the full text of the license see                      #
        # http://www.gnu.org/licenses/gpl-3.0.html                  #
        #-----------------------------------------------------------#

        #---------------------  Changelog  -------------------------#
        #                                                           #
        # 11/12/2009:   Show # of skipped and # packages left.      #
        #               Show preserved libs found and do conf update#
        #               even if some package has failed.            #
        # 11/11/2009:   Bug fix: ACCESS VIOLATION SUMMARY wasn't    #
        #               being caught. This might still be buggy :-/ #
        #               Bug fix: Some packages would output many    #
        #               lines on the countdown.                     #
        #               Bug fix: --resume didn't use to update term #
        #               title. Removed check for --resume now. This #
        #               also allows us to now always remove $tmpE.  #
        #               Show the # of failed packages on exit.      #
        #               Thanks to jw5801 and jprobichaud on gentoo  #
        #               forums for discussion and ideas regarding   #
        #               usage of genlop. Using genlop -f now for the#
        #               merge time calculation.                     #
        #               Broke off all common portions of the script #
        #               into their own functions.                   #
        #               All grep should have LC_ALL="C" in front.   #
        # 11/05/2009:   Bug fix: Workaround bug in genlop again.    #
        #               Bug fix: Pressing just enter should take in #
        #               "yes" as the answer when --ask is used.     #
        # 11/02/2009:   Determine the PORTAGE_TMPDIR by portageq,and#
        #               mount tmpfs on to PORTAGE_TMPDIR/portage    #
        #               Added a new config option: SHOW_MERGE_TIME  #
        #               if it is 1, then time required to merge will#
        #               be shown instead of "Done!"                 #
        #               Bug fix: let us be less exacting on genlop. #
        # 10/30/2009:   Bug fix: Remove the skipped package from tmp#
        #               file so that the correct count and correct  #
        #               remaining time is given by genlop           #
        # 10/29/2009:   Genuine support for --keep-going.           #
        #               Actually calculate the space required by    #
        #               genlop output.                              #
        #               "Time Left" -> "ETA" -- this is shorter     #
        #               Simpler countdown if terminal width is small#
        #               $Self owns the term title, rewrite always!  #
        #               Bug fix: Hopefully, emerge won't output to  #
        #               terminal anymore. Use >& instead of 2>&1    #
        #               Bug fix: Don't output a bogus "Total ETA" if#
        #               emerge failed during --pretend              #
        # 10/27/2009:   Bug fix: Separate $tmpE for $USER and root  #
        #               Bug fix: tmpE should be rm'd on success     #
        # 10/26/2009:   Bug fix: Include infon from my_bash_function#
        # 10/25/2009:   Change grep to LC_ALL=C grep.               #
        #               Give total ETA even with --pretend.         #
        #               Bug fix: overlay was also being printed.    #
        # 10/23/2009:   Exit if --jobs is given.                    #
        #               Give total emerge time est. if -a is present#
        #               Check for root only after pretend stage, so #
        #               even non-root users can use this with -p    #
        #               Add -q to genlop command.                   #
        #               Check MOUNT_TMPFS before unmounting         #
        #               Bug fix: Check whether PID is empty before  #
        #               trying to kill emerge                       #
        # 10/17/2009:   Bug fix: I guess no one tried --resume with #
        #               this script. It was definitely broken ;-)   #
        #               Initial code for --ask. The code can now    #
        #               potentially handle other emerge switches too#
        # 10/12/2009:   Bug fix: avoid setting terminal title when  #
        #               we are in console.                          #
        #               Bug fix: sometimes wrong package count would#
        #               be shown in terminal titlebar.              #
        #               Bug fix: if no pkg has actually been emerged#
        #               then $len remains empty, and a bash error   #
        #               occurs.                                     #
        #               Avoid running genlop when package is being  #
        #               installed (i.e. in install/qmerge stage)    #
        #               Add a Version and a vim Modeline :)         #
        # 10/11/2009:   For eventual release into the gentoo forum: #
        #               1. lots of error checks                     #
        #               2. create a config file. The defaults are   #
        #                  sane. It should not matter if the user   #
        #                  does not modify the config file.         #
        #               3. make tmpfs mounting optional,- disabled  #
        #                  by default.                              #
        #               4. Add a license.                           #
        #               5. Add the functions from my_bash_functions #
        #                  inline in this script.                   #
        # 10/09/2009:   Updated script to show the correct count of #
        #               packages. Also, this warns on B Blocks and  #
        #               interactive packages.                       #
        # 10/03/2009:   First version of the script                 #
        #-----------------------------------------------------------#

#. `which my_bash_functions 2> /dev/null` || {
#    echo -e " \x1b[1;31mError!\x1b[0m The script \x1b[1;32mmy_bash_functions\
#\x1b[0m was not found in your \$PATH
#        Please ensure that the script is available and executable"
#    exit 1
#}

# Set the colors that will be used  # {{{
blue="\x1b[1;34m"
bold="\x1b[1m"
cyan="\x1b[1;36m"
green="\x1b[1;32m"
normal="\x1b[0m"
pink="\x1b[1;35m"
red="\x1b[1;31m"
reverse="\x1b[7m"
underline="\x1b[4m"
yellow="\x1b[1;33m"

# Print out information.
# Usage: info "Whatever you want to print"
info(){
    echo -e "  $yellow*$normal ${@}"
}

# Print out information without ending with a newline. This adds a space at end
# Usage: infon "Whatever you want to print"
infon(){
    echo -ne "  $yellow*$normal ${@} "
}

# info with carriage return at end
infor() {
    echo -ne "  $yellow*$normal $@$(tput el)\r"
}

# Print out error information.
# Usage: Err "Whatever you want to print"
Err(){
    local color="$red" msg="ERROR"
    [[ "$1" = "-w" ]] && color="$pink" && msg="WARNING"
    echo -e "  $color*$normal [$color $msg!!$normal ] ${@/-w/}" >&2
}

die() {
    Err "$@"
    exit 1
}

# Usage: centered_output dash|blank "text string"
# where text is less than cols characters in length
centered_output() {
    local cols=$(tput cols)
    local len="$(echo "$2" | sed -e 's#\\x1[bB]\[[^m]\+m##g')"
    len=${#len}
    if [[ $len -ge $cols ]]; then
        echo -e "$2"
        return
    fi

    # Create D_ASH and BLANK dynamically according to terminal width
    # Solution got via google:
    # http://www.unix.com/shell-programming-scripting/46584-repeat-character-printf.html#post302150959
    printf -vBLANK "%${cols}s" ""
    local D_ASH="${BLANK// /-}"
    local begin=$(( $cols/2 - $len/2 ));    # Length of dash|blank before text
    local end=$(( $cols - $begin - $len )); # Length of dash|blank after text
    if [[ -z "$2" ]]; then
        if [[ "$1" = "dash" ]]; then echo $D_ASH; return
        else echo; return
        fi
    fi
    if [[ "$1" = "dash" ]]; then
        echo -e "${D_ASH:1:$begin}$reverse${2//\\x1[bB]\[0m/\x1b[0m$reverse}\
$normal${D_ASH:1:$end}"
    else
        echo -e "${BLANK:1:$begin}$reverse${2//\\x1[bB]\[0m/\x1b[0m$reverse}\
$normal${BLANK:1:$end}"
    fi
}
# }}}

setup_config_file() {
    info "$yellow$config_dir/$config_file$normal config file not found. Creating ...
    "
    [[ ! -d "$config_dir" ]] && {
        mkdir -p "$config_dir" || die "Could not create $config_dir"
    }
    cat <<END > "$config_dir/$config_file"
# quietemerge config file
#
# Delay after which genlop will be called (in a loop).
# Default is 5 seconds.
# DELAY=5
#
# Should we mount tmpfs on to /var/tmp/portage? This should be used only
# if you have enough RAM. For example emerging gcc with +java USE flag
# requires about 2G RAM for storage. Emerging openoffice probably requires
# even more. Change value to 1 to enable tmpfs. Default is 0 (no).
# MOUNT_TMPFS=0
#
# Amount of RAM that will be mounted on to /var/tmp/portage if MOUNT_TMPFS
# is 1.
# See the man page of mount for the values that can be given to TMPFS_SIZE.
# Look for the valid values of the "size" mount option of tmpfs.
# Default is half the size of your total RAM.
# TMPFS_SIZE=50%
#
# The console based program that is used to update /etc,/usr config files
# Examples of such programs are cfg-update, dispatch-conf, etc-update,
# etc-proposals, conf-update
# Default is empty.
# TXT_UPDATER=""
#
# The graphical program that is used to update /etc,/usr config files
# Examples are cfg-update, etc-proposals.
# Default is TXT_UPDATER
# GUI_UPDATER="\$TXT_UPDATER"
# 
# Whether we should display the latest merge time instead of "Done!" after
# a package has been emerged. Default is 0 (no). Set it to 1 to enable it.
# SHOW_MERGE_TIME=0

END

info "Open $yellow$config_dir/$config_file$normal and modify the settings
    to your own liking.
    "
    sleep 5
}

# Help me!! {{{
help() {
    local self="${0##*\/}"
    echo -e "\n $yellow $self:$normal"
    info "This program is used to perform the emerge with pretty output.
    It uses app-portage/genlop to provide an estimate of the time left.
    Version: 20091112
    "
    info "License: GPL-3
    Copyright (C) 2009  ppurka _at_ gmail _dot_ com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    "

    info "Usage:     $self [<options>]"
    info "Options:
    -h | --help     Show this help text

    All other options are passed directly to emerge.
    Additionally, the option -q is provided to emerge by default.
    If no arguments are provided to $self, then this help text is shown.
    "
    info "The following options of emerge should not be provided to this
    script. ${red}No error checks are performed to see if the options
    passed to the script adhere to these suggestions.$normal
    --jobs=<num>, --sync, -C, -c
    There may also be other options of emerge which break this script.
    "

    info "Configuration:
    Some basic configuration related to this script is stored in
    $yellow$config_dir/$config_file$normal
    "
    info "Examples on how to call this script:
    $self -uD world
    $self -1 glibc vim
    $self --resume
    "
}
# }}}


config_dir=$HOME/.config
config_file="${0##*\/}.config"
# Display help in xterm if user clicked on the file
if [[ -z "$@" && "$DISPLAY" ]] && ! tty -s; then
    xterm -hold -e "$(dirname $0)/$(basename $0)" -h; exit
elif [[ -z "$@" || "$@" = -h* || "$@" = --h* ]]; then
    help
    exit
fi

# Source the config file
if [[ -f "$config_dir/$config_file" ]]; then
    . "$config_dir/$config_file"
else
    setup_config_file
    exit
fi


# Variables used in this script. Modify only if you know what you are doing
TMPFILE=/tmp/output.log
tmpE=/tmp/tmpE.$UID
tmpT=/tmp/tmpT
: ${DELAY:=5}
: ${MOUNT_TMPFS:=0}
: ${SHOW_MERGE_TIME:=0}
_num=0                  # The number of the package being emerged.
cmdline=""              # This will hold the arguments passed to emerge
e_opt_ask=0             # If it is 1, then ask before emerging
e_opt_pretend=0         # If it is 1, then only pretend the emerge
e_opt_verbose=""        # If it is -v, then emerge -vq is launched
eta=0                   # The total time left for the remaining packages
exit_status=( 0 0 )     # This counts the # of failed and skipped packages
my_len=19               # This is the length of "  * Emerging . ETA:"
PID=""                  # The pid of emerge process
pkg=""                  # This holds the name of current pkg being emerged


# Mounting and unmounting tmpfs. These fns take no argument #{{{
mount_tmpfs() {
    [[ $MOUNT_TMPFS -ne 1 ]] && return 0
    local var_tmp="$(portageq envvar PORTAGE_TMPDIR)/portage"
    if mount | grep -q -s -w "tmpfs on $var_tmp"; then
        info "tmpfs is already mounted\n"
    elif [[ "$TMPFS_SIZE" ]]; then
        mount -t tmpfs -o size=${TMPFS_SIZE} tmpfs $var_tmp
    else
        mount -t tmpfs tmpfs $var_tmp
    fi
    [[ $? -ne 0 ]] && die "Error in mounting tmpfs\n"
}
unmount_tmpfs() {
    # Do not mess with tmpfs mounted without this script
    [[ $MOUNT_TMPFS -ne 1 ]] && return 0
    local var_tmp="$(portageq envvar PORTAGE_TMPDIR)/portage"
    if [[ $UID -eq 0 ]] && mount | grep -q -s -w "tmpfs on $var_tmp"; then
        umount $var_tmp
    fi
    [[ $? -ne 0 ]] && die "Error in unmounting tmpfs\n"
} 
# }}}

# Functions specific to this script {{{
# Usage: exit_prog [<exit status>]
exit_prog() {
    [[ -f "$tmpE" ]] && rm -f $tmpE
    [[ -f "$tmpT" ]] && rm -f $tmpT
    echo        # I like echoes!
    # If emerge process is running and the script has reached here, then
    # kill the emerge process.
    if [[ "$PID" ]] && ps -p $PID >& /dev/null; then
        Err -w "The emerge process given by PID: $PID is still running.
    The emerge process will be killed.\n"
        kill $PID
        [[ $MOUNT_TMPFS -eq 1 ]] && sleep 2     # Allow emerge to finish
    fi
    [[ "$@" -eq 0 ]] && unmount_tmpfs           # Unmount only if status=0
    echo    # This is here so that the exit below takes status of $@
    exit $@
}

# Usage: failed_pkgs
failed_pkgs(){
    # This expression is MASSIVE!!
    # This expression relies on the fact that emerge will not
    # fail on still another package within $DELAY seconds. So,
    # it searches for all --keep-going till the end of the file
    # sed -n -e "/Failed.*${pkg%%\/*}\/${pkg##*\/}/,\$s/.*emerge --keep-going: \([^ ]*\) dropped.*/  $pink* Skipped  \1$normal due to --keep-going/p" $TMPFILE
    for p in $( sed -n -e "/Failed.*${pkg%%\/*}\/${pkg##*\/}/,\$s/.*emerge --keep-going: \([^ ]*\) dropped.*/\1/p" $TMPFILE ); do
        # Delete packages from tmpE so that count is correct.
        sed -i -e "/${p%%/*}\/${p##*/}/d" $tmpE
        ((exit_status[1]++))
        echo -e "$pink  * Skipped  $p$normal due to --keep-going"
    done
}

# This is used to print on the left and right with blanks in between
# Usage: infolr <info|infor> "left aligned text" "right aligned text"
infolr() {
    [[ "$3" ]] || {
        $1 "$2$(tput el)"
        return
    }

    # Note that "  * " at the beginning requires 4 characters.
    local left="$( echo "$2" | sed -e 's#\\x1[bB]\[[^m]\+m##g' )"
    local right="$( echo "$3" | sed -e 's#\\x1[bB]\[[^m]\+m##g' )"
    local middle=$(( $cols -4 - ${#left} - ${#right} ))
    [[ $middle -le 0 ]] && middle=1

    $1 "$2${BLANK:1:$middle}$3"
}

# Usage: merge_time "cat/pkg-ver"
merge_time() {
    if [[ $SHOW_MERGE_TIME -eq 1 ]]; then
        # Hopefully there won't be too many lines appended to log file
        # within 5 seconds. So, 40 should be a safe limit.
        tail -n 40 /var/log/emerge.log > $tmpT 2> /dev/null
        genlop -f $tmpT -nt "$1" 2> /dev/null \
            | sed -n '/merge time:/s/.*: \(.*\)$/\1/p' | tail -n 1
    else
        echo "Done! "
    fi
}

# Usage: parse_cmdline "-some_command"
parse_cmdline(){
    local cmd="$1"
    # Check for -a embedded in the command
    if [[ "$cmd" =~ -[b-zA-Z0-9]*a[b-zA-Z0-9]* ]]; then
        cmd="${cmd/a/}"
        e_opt_ask=1
    fi

    # Check for -p embedded in the command
    if [[ "$cmd" =~ -[a-oq-zA-Z0-9]*p[a-oq-zA-Z0-9]* ]]; then
        cmd="${cmd/p/}"
        e_opt_pretend=1
    fi

    # Check for -q embedded in the command
    if [[ "$cmd" =~ -[a-pr-zA-Z0-9]*q[a-pr-zA-Z0-9]* ]]; then
        cmd="${cmd/q/}"
    fi

    # Check for -v embedded in the command
    if [[ "$cmd" =~ -[a-uw-zA-Z0-9]*v[a-uw-zA-Z0-9]* ]]; then
        cmd="${cmd/v/}"
        e_opt_verbose="-v"
    fi

    # If there is any other option left, then assign it
    [[ "$cmd" != "-" ]] && cmdline="$cmdline $cmd"
}


# Usage: update_term_title
update_term_title() {
    # Don't try to update the terminal title of console!
    [[ "$DISPLAY" ]] || return
    [[ -f $tmpE ]]   || return

    _num="$(wc -l $tmpE)"; _num="${_num%% *}"
    # tmp holds the total ETA
    eta="$(cat $tmpE | genlop -npq | \
        sed -n -e '/Estimated update time/s/^.*: \(.*\)$/\1/p' )"
    # Change the terminal title
    echo -ne "\x1b]0;$(($_total_num - $_num + 1))/$_total_num: ${pkg#*\/},\
 Total ETA: ${eta}\007"
}

# End. Fns specific to script }}}



# Try to exit gracefully.
trap "exit_prog 1" 1 2 5 15

# First some error checking.
which genlop >& /dev/null || \
    die "This script requires ${cyan}app-portage/genlop$normal installed.
    Is genlop installed and in your \$PATH?\n"


# Main program starts here.
# Nice output
# First parse the command line
until [[ -z "$1" ]]; do
    case "$1" in
        -a|--ask)       e_opt_ask=1;;
        -j*|--jobs)     die "-j or --jobs is not allowed. Use emerge
    directly if you want this functionality.";;
        -p|--pretend)   e_opt_pretend=1;;
        -q|--quiet)     ;;
        -v|--verbose)   e_opt_verbose="-v";;
        --*)            cmdline="$cmdline $1";;
        -*)             parse_cmdline "$1";;
        *)              cmdline="$cmdline $1";;
    esac
    shift
done

# Pretend emerge. If it fails, exit. Also do some error checking.
centered_output dash " Pretended emerge "
emerge --color=y -p $e_opt_verbose $cmdline | tee -i $tmpE
status="${PIPESTATUS[0]}"

# Clean up tmpE of all colors.
sed -i -e 's/\[[^m]*m//g' $tmpE

[[ $status -eq 0 ]] && {
    echo
    infor "Estimating total update time ..."
    centered_output blank " Total ETA: $(cat $tmpE | genlop -npq | \
        sed -n -e '/Estimated update time/s/^.*: \(.*\)$/\1/p' ) "
    echo
}

# Now check the command line options for further instructions
[[ $e_opt_pretend -eq 1 ]] && exit_prog $status

# Check for root now
[[ $UID -eq 0 ]] || die "root login is required to actually emerge."

# Error checking
LC_ALL="C" grep -q '^\[ebuild[ ]*I' $tmpE && \
    Err -w "Some packages require user interaction. This script
    will now exit." && \
    exit_prog
LC_ALL="C" grep -q '^\[blocks[ ]*B' $tmpE && \
    Err "Hard blocks have been identified. This script will now exit." && \
    exit_prog $status
LC_ALL="C" grep -q '^\[blocks[ ]*b' $tmpE && \
    info "Soft blocks have been identified. The emerge process will resolve
    the blocks automatically\n"
# More error checks. Check if emerge exited with 0 return value.
[[ $status -ne 0 ]] && exit_prog $status
unset status

# Fix the output in tmpE -- keep only packages to be emerged.
sed -i -e '/^\[ebuild/!d' $tmpE

# --ask was provided in some form in command line.
[[ $e_opt_ask -eq 1 ]] && {
    # Provide a total estimate of the time
    infon "Continue with the emerge process? \
([${green}Y${normal}es]|${red}N${normal}o):"
    read -n 1 tmp; echo
    case "$tmp" in
        ""|[yY]*)  ;;
        *)      exit_prog;;
    esac
}

# Total number of packages which are going to be emerged.
_total_num="$(wc -l $tmpE)"; _total_num="${_total_num%% *}"

# Mount the tmpfs if asked for
mount_tmpfs

# Start the actual emerge
emerge -q $cmdline >& $TMPFILE &
PID=$!

echo
if [[ "$@" = *--resume* ]]; then
    centered_output dash " Resuming merge "
else
    centered_output dash " Starting emerge "
fi
echo

# Wait till emerge starts spitting out "emerging cat/pkg"
while ps -p $PID >& /dev/null && \
    ! LC_ALL="C" grep -qsE -m1 "(Emerging|Installing)" $TMPFILE; do
    sleep $DELAY
done

while ps -p $PID >& /dev/null; do
    # Some package is still being emerged.
    tmp="$( tac $TMPFILE | LC_ALL="C" grep -E -m1 '(Emerging|Installing)' )"
    # pkg_tmp contains the package currently being emerged. pkg contains
    # the package which was being emerged $DELAY seconds earlier.
    pkg_tmp="$( echo "$tmp" | sed -n -e 's/.*) \([^ ]*\)[ ]\?.*$/\1/p' )"
    if [[ "$pkg_tmp" != "$pkg" ]]; then
        if [[ -n "$pkg" ]]; then
            # Delete package from tmpE so that count is correct.
            sed -i -e "/${pkg%%/*}\/${pkg##*/}/d" $tmpE
            if LC_ALL="C" grep -q "Failed to emerge.*$pkg" $TMPFILE; then
                # An error occured :-S
                infolr info "Install  $cyan$pkg$normal." "${red}Error!$normal "
                ((exit_status++))
                # Now check for packages which have been skipped.
                failed_pkgs
            else
                infolr info "Install  $cyan$pkg$normal." \
                    "$green$( merge_time "=$pkg" )$normal"
            fi
        fi
        pkg="$pkg_tmp"
        len=${#pkg}
        update_term_title
        cols=$(tput cols)       # In case the terminal size changed
        printf -vBLANK "%${cols}s" ""

        # Find out the total length of the line that will be printed
        # Now, pkg_tmp contains the string of max length of genlop -c
        # possible for this package.
        pkg_tmp="$( sed -n -e "/${pkg%%/*}\/${pkg##*/}/p" $tmpE | \
            genlop -npq | \
            sed -n -e '/Estimated update time/s/^.*: \(.*\)$/\1/p' )"
        # Here 9 is totally arbitrary and is meant to take care of
        # situations where genlop -p says "2 minutes" and the countdown
        # later says "1 minute 55 seconds". Hopefully, it acts as a safety
        # net so that the user never gets a messy display.
        total_len=$(( $my_len + $len + ${#pkg_tmp} + 9 ))
    fi
    if [[ "$tmp" = *Emerging* ]]; then
        if [[ $total_len -lt $cols ]]; then
            tmp="$( genlop -nqc | sed -n '/ETA: /s/^[ ]*ETA:[ ]*//p' )"
            infolr infor "Emerging $cyan$pkg$normal. ETA:" "$tmp"
        elif [[ $(( $total_len - 14 )) -lt $cols ]]; then
            # We will print an even more simpler expression!!
            tmp="$( genlop -nqc | sed -n '/ETA: /s/^[ ]*ETA:[ ]*//p' )"
            infolr infor "$cyan$pkg$normal:" "$tmp"
        else
            infor "Emerging $cyan$pkg$normal.$(tput el)"
        fi
    else
        infor "Installing $cyan$pkg$normal.$(tput el)"
    fi
    # Change the terminal title -- this is a constant fight with emerge!!
    # Hope the terminal doesn't mind! ;-)
    [[ "$DISPLAY" ]] && \
    echo -ne "\x1b]0;$(($_total_num - $_num + 1))/$_total_num: \
${pkg#*\/}, Total ETA: ${eta}\007"

    sleep $DELAY
done

# Either the emerge process is finished or there has been some
# error in the process
if LC_ALL="C" grep -qi "error.*$pkg fail" $TMPFILE || \
    LC_ALL="C" grep -q "ACCESS VIOLATION SUMMARY" $TMPFILE || \
    tail -n 25 $TMPFILE | LC_ALL="C" grep -qiE "^\!\!\!.*(abort|error)"; then
    infolr info "Emerging $cyan$pkg$normal." "${red}Error!$normal "
    ((exit_status++))
    failed_pkgs
    _total_num="$(wc -l $tmpE)"; _total_num="$(( ${_total_num%% *} - 1 ))"
    # Some error happened -- we will not use exit_prog; tmpfs data will
    # remain preserved then.
    Err "Emerge: $red$exit_status failed, $pink${exit_status[1]} skipped, \
$green$_total_num left$normal
    The last few lines of emerge are:\n$(tail -n 25 $TMPFILE)

    See $yellow$TMPFILE$normal for the full error message.
    "
    sleep 1
elif [[ $exit_status -ne 0 ]]; then
    # The latest package emerged fine. Otherwise the error would be picked
    # up by the previous line.
    infolr info "Install  $cyan$pkg$normal." \
        "${green}$( merge_time "=$pkg" )$normal"
    _total_num="$(wc -l $tmpE)"; _total_num="$(( ${_total_num%% *} - 1 ))"
    Err "Emerge: $red$exit_status failed, $pink${exit_status[1]} skipped, \
$green$_total_num left$normal
    See $yellow$TMPFILE$normal.
    "
    sleep 1
else
    # Looks like everything went fine :-/
    # Bug fix: check that $len is actually non-empty.
    [[ "$len" ]] && infolr info "Install  $cyan$pkg$normal." \
        "$green$( merge_time "=$pkg" )$normal"
fi

# The emerge process is over. Now check for preserved rebuild notice
tail $TMPFILE | LC_ALL="C" grep -qi "preserved" && \
info "Preserved libraries found: See $yellow$TMPFILE$normal"

# Update config files.
if [[ "$TXT_UPDATER" || "$GUI_UPDATER" ]] && \
    tail $TMPFILE | LC_ALL="C" grep -qEi -m1 "config.*updat"; then
    centered_output dash " Updating config files "

    # Handle some error cases
    [[ "$TXT_UPDATER" && -z "$GUI_UPDATER" ]] && \
        GUI_UPDATER="$TXT_UPDATER"

    if [[ -n "$DISPLAY" ]]; then
            $GUI_UPDATER
    elif [[ "$TXT_UPDATER" ]]; then
            $TXT_UPDATER
    else
        Err "No config file updater was found. Check your settings in
    $yellow$config_dir/$config_file$normal\n"
    fi
elif tail $TMPFILE | LC_ALL="C" grep -qEi -m1 "config.*updat"; then
    info "There are pending configuration updates:
$(tail $TMPFILE)

    See $yellow$TMPFILE$normal for more information.
"
fi

exit_prog $exit_status

# vim: set ai et fdm=marker ff=unix sta sts=4 sw=4 ts=4 tw=75 : 
