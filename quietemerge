#!/bin/bash

        #-----------------------------------------------------------#
        #   This program is used to make emerge output pretty       #
        #   Version: 20091029                                       #
        #                                           -ppurka         #
        #-----------------------------------------------------------#

        #--------------------- License: GPL-3  ---------------------#
        # Copyright (C) 2009  ppurka _at_ gmail _dot_ com           #
        # This program comes with ABSOLUTELY NO WARRANTY;           #
        # This is free software, and you are welcome to redistribute#
        # it under certain conditions;                              #
        #                                                           #
        # For a brief summary of the license see the help text of   #
        # this program by executing:                                #
        # quietemerge --help                                        #
        #                                                           #
        # For the full text of the license see                      #
        # http://www.gnu.org/licenses/gpl-3.0.html                  #
        #-----------------------------------------------------------#

        #---------------------  Changelog  -------------------------#
        #                                                           #
        # 10/29/2009:   Genuine support for --keep-going.           #
        #               Actually calculate the space required by    #
        #               genlop output.                              #
        #               "Time Left" -> "ETA" -- this is shorter     #
        #               Simpler countdown if terminal width is small#
        #               $Self owns the term title, rewrite always!  #
        #               Bug fix: Hopefully, emerge won't output to  #
        #               terminal anymore. Use >& instead of 2>&1    #
        #               Bug fix: Don't output a bogus "Total ETA" if#
        #               emerge failed during --pretend              #
        # 10/27/2009:   Bug fix: Separate $tmpE for $USER and root  #
        #               Bug fix: tmpE should be rm'd on success     #
        # 10/26/2009:   Bug fix: Include infon from my_bash_function#
        # 10/25/2009:   Change grep to LC_ALL=C grep.               #
        #               Give total ETA even with --pretend.         #
        #               Bug fix: overlay was also being printed.    #
        # 10/23/2009:   Exit if --jobs is given.                    #
        #               Give total emerge time est. if -a is present#
        #               Check for root only after pretend stage, so #
        #               even non-root users can use this with -p    #
        #               Add -q to genlop command.                   #
        #               Check MOUNT_TMPFS before unmounting         #
        #               Bug fix: Check whether PID is empty before  #
        #               trying to kill emerge                       #
        # 10/17/2009:   Bug fix: I guess no one tried --resume with #
        #               this script. It was definitely broken ;-)   #
        #               Initial code for --ask. The code can now    #
        #               potentially handle other emerge switches too#
        # 10/12/2009:   Bug fix: avoid setting terminal title when  #
        #               we are in console.                          #
        #               Bug fix: sometimes wrong package count would#
        #               be shown in terminal titlebar.              #
        #               Bug fix: if no pkg has actually been emerged#
        #               then $len remains empty, and a bash error   #
        #               occurs.                                     #
        #               Avoid running genlop when package is being  #
        #               installed (i.e. in install/qmerge stage)    #
        #               Add a Version and a vim Modeline :)         #
        # 10/11/2009:   For eventual release into the gentoo forum: #
        #               1. lots of error checks                     #
        #               2. create a config file. The defaults are   #
        #                  sane. It should not matter if the user   #
        #                  does not modify the config file.         #
        #               3. make tmpfs mounting optional,- disabled  #
        #                  by default.                              #
        #               4. Add a license.                           #
        #               5. Add the functions from my_bash_functions #
        #                  inline in this script.                   #
        # 10/09/2009:   Updated script to show the correct count of #
        #               packages. Also, this warns on B Blocks and  #
        #               interactive packages.                       #
        # 10/03/2009:   First version of the script                 #
        #-----------------------------------------------------------#

#. `which my_bash_functions 2> /dev/null` || {
#    echo -e " \x1b[1;31mError!\x1b[0m The script \x1b[1;32mmy_bash_functions\
#\x1b[0m was not found in your \$PATH
#        Please ensure that the script is available and executable"
#    exit 1
#}

# Set the colors that will be used  # {{{
blue="\x1b[1;34m"
bold="\x1b[1m"
cyan="\x1b[1;36m"
green="\x1b[1;32m"
normal="\x1b[0m"
pink="\x1b[1;35m"
red="\x1b[1;31m"
reverse="\x1b[7m"
underline="\x1b[4m"
yellow="\x1b[1;33m"

# Print out information.
# Usage: info "Whatever you want to print"
info(){
    echo -e "  $yellow*$normal ${@}"
}

# Print out information without ending with a newline. This adds a space at end
# Usage: infon "Whatever you want to print"
infon(){
    echo -ne "  $yellow*$normal ${@} "
}

# info with carriage return at end
infor() {
    echo -ne "  $yellow*$normal $@$(tput el)\r"
}

# Print out error information.
# Usage: Err "Whatever you want to print"
Err(){
    local color="$red" msg="ERROR"
    [[ "$1" = "-w" ]] && color="$pink" && msg="WARNING"
    echo -e "  $color*$normal [$color $msg!!$normal ] ${@/-w/}" >&2
}

die() {
    Err "$@"
    exit 1
}

# Usage: centered_output dash|blank "text string"
# where text is less than cols characters in length
centered_output() {
    local cols=$(tput cols)
    local len="$(echo "$2" | sed -e 's#\\x1[bB]\[[^m]\+m##g')"
    len=${#len}
    if [[ $len -ge $cols ]]; then
        echo -e "$2"
        return
    fi

    # Create D_ASH and BLANK dynamically according to terminal width
    # Solution got via google:
    # http://www.unix.com/shell-programming-scripting/46584-repeat-character-printf.html#post302150959
    printf -vBLANK "%${cols}s" ""
    local D_ASH="${BLANK// /-}"
    local begin=$(( $cols/2 - $len/2 ));    # Length of dash|blank before text
    local end=$(( $cols - $begin - $len )); # Length of dash|blank after text
    if [[ -z "$2" ]]; then
        if [[ "$1" = "dash" ]]; then echo $D_ASH; return
        else echo; return
        fi
    fi
    if [[ "$1" = "dash" ]]; then
        echo -e "${D_ASH:1:$begin}$reverse${2//\\x1[bB]\[0m/\x1b[0m$reverse}\
$normal${D_ASH:1:$end}"
    else
        echo -e "${BLANK:1:$begin}$reverse${2//\\x1[bB]\[0m/\x1b[0m$reverse}\
$normal${BLANK:1:$end}"
    fi
}
# }}}

setup_config_file() {
    info "$yellow$config_dir/$config_file$normal config file not found. Creating ...
    "
    [[ ! -d "$config_dir" ]] && {
        mkdir -p "$config_dir" || die "Could not create $config_dir"
    }
    cat <<END > "$config_dir/$config_file"
# quietemerge config file
#
# Delay after which genlop will be called (in a loop).
# Default is 5 seconds.
# DELAY=5
#
# Should we mount tmpfs on to /var/tmp/portage? This should be used only
# if you have enough RAM. For example emerging gcc with +java USE flag
# requires about 2G RAM for storage. Emerging openoffice probably requires
# even more. Change value to 1 to enable tmpfs. Default is 0 (no).
# MOUNT_TMPFS=0
#
# Amount of RAM that will be mounted on to /var/tmp/portage if MOUNT_TMPFS
# is 1.
# See the man page of mount for the values that can be given to TMPFS_SIZE.
# Look for the valid values of the "size" mount option of tmpfs.
# Default is half the size of your total RAM.
# TMPFS_SIZE=50%
#
# The console based program that is used to update /etc,/usr config files
# Examples of such programs are cfg-update, dispatch-conf, etc-update,
# etc-proposals, conf-update
# Default is empty.
# TXT_UPDATER=""
#
# The graphical program that is used to update /etc,/usr config files
# Examples are cfg-update, etc-proposals.
# Default is TXT_UPDATER
# GUI_UPDATER="\$TXT_UPDATER"

END

info "Open $yellow$config_dir/$config_file$normal and modify the settings
    to your own liking.
    "
    sleep 5
}

# Help me!! {{{
help() {
    local self="${0##*\/}"
    echo -e "\n $yellow $self:$normal"
    info "This program is used to perform the emerge with pretty output.
    It uses app-portage/genlop to provide an estimate of the time left.
    Version: 20091029
    "
    info "License: GPL-3
    Copyright (C) 2009  ppurka _at_ gmail _dot_ com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    "

    info "Usage:     $self [<options>]"
    info "Options:
    -h | --help     Show this help text

    All other options are passed directly to emerge.
    Additionally, the option -q is provided to emerge by default.
    If no arguments are provided to $self, then this help text is shown.
    "
    info "The following options of emerge should not be provided to this
    script. ${red}No error checks are performed to see if the options
    passed to the script adhere to these suggestions.$normal
    --jobs=<num>, --sync, -C, -c
    There may also be other options of emerge which break this script.
    "

    info "Configuration:
    Some basic configuration related to this script is stored in
    $yellow$config_dir/$config_file$normal
    "
    info "Examples on how to call this script:
    $self -uD world
    $self -1 glibc vim
    $self --resume
    "
}
# }}}


config_dir=$HOME/.config
config_file="${0##*\/}.config"
# Display help in xterm if user clicked on the file
if [[ -z "$@" && "$DISPLAY" ]] && ! tty -s; then
    xterm -hold -e "$(dirname $0)/$(basename $0)" -h; exit
elif [[ -z "$@" || "$@" = -h* || "$@" = --h* ]]; then
    help
    exit
fi

# Source the config file
if [[ -f "$config_dir/$config_file" ]]; then
    . "$config_dir/$config_file"
else
    setup_config_file
    exit
fi


# Variables used in this script. Modify only if you know what you are doing
TMPFILE=/tmp/output.log
tmpE=/tmp/tmpE.$UID
: ${MOUNT_TMPFS:=0}
: ${DELAY:=5}
_num=0                  # The number of the package being emerged.
cmdline=""              # This will hold the arguments passed to emerge
e_opt_ask=0             # If it is 1, then ask before emerging
e_opt_pretend=0         # If it is 1, then only pretend the emerge
e_opt_verbose=""        # If it is -v, then emerge -vq is launched
eta=0                   # The total time left for the remaining packages
exit_status=0           # Hopefully this remains 0 throughout.
my_len=19               # This is the length of "  * Emerging . ETA:"
PID=""                  # The pid of emerge process
pkg=""                  # This holds the name of current pkg being emerged


# Mounting and unmounting tmpfs. These fns take no argument #{{{
mount_tmpfs() {
    [[ $MOUNT_TMPFS -ne 1 ]] && return 0
    if mount | grep -q -s -w "tmpfs on /var/tmp/portage"; then
        info "tmpfs is already mounted\n"
    elif [[ "$TMPFS_SIZE" ]]; then
        mount -t tmpfs -o size=${TMPFS_SIZE} tmpfs /var/tmp/portage
    else
        mount -t tmpfs tmpfs /var/tmp/portage
    fi
    [[ $? -ne 0 ]] && die "Error in mounting tmpfs\n"
}
unmount_tmpfs() {
    # Do not mess with tmpfs mounted without this script
    [[ $MOUNT_TMPFS -ne 1 ]] && return 0
    if [[ $UID -eq 0 ]] && mount | \
        grep -q -s -w "tmpfs on /var/tmp/portage"; then
        umount /var/tmp/portage
    fi
    [[ $? -ne 0 ]] && die "Error in unmounting tmpfs\n"
} 
# }}}

# Usage: exit_prog [<exit status>]
exit_prog() {
    # If exit status is zero then remove tmpE
    [[ "$@" ]] || rm -f $tmpE
    echo        # I like echoes!
    # If emerge process is running and the script has reached here, then
    # kill the emerge process.
    if [[ "$PID" ]] && ps -p $PID >& /dev/null; then
        Err -w "The emerge process given by PID: $PID is still running.
    The emerge process will be killed.\n"
        kill $PID
        [[ $MOUNT_TMPFS -eq 1 ]] && sleep 2     # Allow emerge to finish
    fi
    unmount_tmpfs
    echo    # This is here so that the exit below takes status of $@
    exit $@
}

parse_cmdline(){
    local cmd="$1"
    # Check for -a embedded in the command
    if [[ "$cmd" =~ -[b-zA-Z0-9]*a[b-zA-Z0-9]* ]]; then
        cmd="${cmd/a/}"
        e_opt_ask=1
    fi

    # Check for -p embedded in the command
    if [[ "$cmd" =~ -[a-oq-zA-Z0-9]*p[a-oq-zA-Z0-9]* ]]; then
        cmd="${cmd/p/}"
        e_opt_pretend=1
    fi

    # Check for -q embedded in the command
    if [[ "$cmd" =~ -[a-pr-zA-Z0-9]*q[a-pr-zA-Z0-9]* ]]; then
        cmd="${cmd/q/}"
    fi

    # Check for -v embedded in the command
    if [[ "$cmd" =~ -[a-uw-zA-Z0-9]*v[a-uw-zA-Z0-9]* ]]; then
        cmd="${cmd/v/}"
        e_opt_verbose="-v"
    fi

    # If there is any other option left, then assign it
    [[ "$cmd" != "-" ]] && cmdline="$cmdline $cmd"
}


update_term_title() {
    # Don't try to update the terminal title of console!
    [[ "$DISPLAY" ]] || return
    [[ -f $tmpE ]]   || return

    _num="$(wc -l $tmpE)"; _num="${_num%% *}"
    # tmp holds the total ETA
    eta="$(cat $tmpE | genlop -npq | \
        sed -n -e '/Estimated update time/s/^.*: \(.*\)$/\1/p' )"
    # Change the terminal title
    echo -ne "\x1b]0;$(($_total_num - $_num + 1))/$_total_num: ${pkg#*\/},\
 Total ETA: ${eta}\007"
}


# Try to exit gracefully.
trap "exit_prog 1" 1 2 5 15

# First some error checking.
which genlop >& /dev/null || \
    die "This script requires ${cyan}app-portage/genlop$normal installed.
    Is genlop installed and in your \$PATH?\n"


# Main program starts here.
# Nice output
if [[ "$@" = "--resume" ]]; then
    cmdline="$@"
else
    # First parse the command line
    until [[ -z "$1" ]]; do
        case "$1" in
            -a|--ask)       e_opt_ask=1;;
            -j*|--jobs)     die "-j or --jobs is not allowed. Use emerge
    directly if you want this functionality.";;
            -p|--pretend)   e_opt_pretend=1;;
            -q|--quiet)     ;;
            -v|--verbose)   e_opt_verbose="-v";;
            --*)            cmdline="$cmdline $1";;
            -*)             parse_cmdline "$1";;
            *)              cmdline="$cmdline $1";;
        esac
        shift
    done

    # Pretend emerge. If it fails, exit. Also do some error checking.
    centered_output dash " Pretended emerge "
    emerge --color=y -p $e_opt_verbose $cmdline | tee -i $tmpE
    status="${PIPESTATUS[0]}"

    # Clean up tmpE of all colors.
    sed -i -e 's/\[[^m]*m//g' $tmpE

    [[ $status -eq 0 ]] && {
        echo
        infor "Estimating total update time ..."
        centered_output blank " Total ETA: $(cat $tmpE | genlop -npq | \
            sed -n -e '/Estimated update time/s/^.*: \(.*\)$/\1/p' ) "
        echo
    }

    # Now check the command line options for further instructions
    [[ $e_opt_pretend -eq 1 ]] && exit_prog $status

    # Check for root now
    [[ $UID -eq 0 ]] || die "root login is required to actually emerge."

    # Error checking
    LC_ALL="C" grep -q '^\[ebuild[ ]*I' $tmpE && \
        Err -w "Some packages require user interaction. This script
    will now exit." && \
        exit_prog
    LC_ALL="C" grep -q '^\[blocks[ ]*B' $tmpE && \
        Err "Hard blocks have been identified. This script will now exit." && \
        exit_prog $status
    LC_ALL="C" grep -q '^\[blocks[ ]*b' $tmpE && \
        info "Soft blocks have been identified. The emerge process will resolve
    the blocks automatically\n"
    # More error checks. Check if emerge exited with 0 return value.
    [[ $status -ne 0 ]] && exit_prog $status
    unset status

    # Fix the output in tmpE -- keep only packages to be emerged.
    sed -i -e '/^\[ebuild/!d' $tmpE

    # --ask was provided in some form in command line.
    [[ $e_opt_ask -eq 1 ]] && {
        # Provide a total estimate of the time
        infon "Continue with the emerge process? \
([${green}Y${normal}es]|${red}N${normal}o):"
        read -n 1 tmp; echo
        case "$tmp" in
            [yY]*)  ;;
            *)      exit_prog;;
        esac
    }

    # Total number of packages which are going to be emerged.
    _total_num="$(wc -l $tmpE)"; _total_num="${_total_num%% *}"
fi

# Mount the tmpfs if asked for
mount_tmpfs

# Start the actual emerge
emerge -q $cmdline >& $TMPFILE &
PID=$!

echo
if [[ "$@" = "--resume" ]]; then
    centered_output dash " Resuming merge "
else
    centered_output dash " Starting emerge "
fi
echo

# Wait till emerge starts spitting out "emerging cat/pkg"
while ps -p $PID >& /dev/null && \
    ! LC_ALL="C" grep -qsE -m1 "(Emerging|Installing)" $TMPFILE; do
    sleep $DELAY
done

while ps -p $PID >& /dev/null; do
    # Some package is still being emerged.
    tmp="$( tac $TMPFILE | LC_ALL="C" grep -E -m1 '(Emerging|Installing)' )"
    # pkg_tmp contains the package currently being emerged. pkg contains
    # the package which was being emerged $DELAY seconds earlier.
    pkg_tmp="$( echo "$tmp" | sed -n -e 's/.*) \([^ ]*\)[ ]\?.*$/\1/p' )"
    if [[ "$pkg_tmp" != "$pkg" ]]; then
        if [[ -n "$pkg" ]]; then
            if grep -q "Failed to emerge.*$pkg" $TMPFILE; then
                # An error occured :-S
                blen=$(( $cols - $my_len - 2 - $len ))
                info "Install  $cyan$pkg$normal.${BLANK:1:$blen}\
${red}Error!$normal "
                exit_status=1
                # Now check for packages which have been skipped.
                # This expression is MASSIVE!!
                # This expression relies on the fact that emerge will not
                # fail on still another package within $DELAY seconds. So,
                # it searches for all --keep-going till the end of the file
                sed -n -e "/Failed.*${pkg%%\/*}\/${pkg##*\/}/,\$s/.*emerge --keep-going: \([^ ]*\) dropped.*/  $pink* Skipped  \1$normal due to --keep-going/p" $TMPFILE
            else
                sed -i -e "/${pkg%%\/*}\/${pkg##*\/}/d" $tmpE
                # This needs 1 more character than my_len
                blen=$(( $cols - $my_len - 1 - $len ))
                info "Install  $cyan$pkg$normal.${BLANK:1:$blen}\
${green}Done!$normal "
            fi
        fi
        pkg="$pkg_tmp"
        update_term_title
        cols=$(tput cols)       # In case the terminal size changed
        printf -vBLANK "%${cols}s" ""
        len=${#pkg}

        # Find out the total length of the line that will be printed
        # Now, pkg_tmp contains the string of max length of genlop -c
        # possible for this package.
        pkg_tmp="$( sed -n -e "/${pkg%%/*}\/${pkg##*/}/p" $tmpE | \
            genlop -npq | \
            sed -n -e '/Estimated update time/s/^.*: \(.*\)$/\1/p' )"
        # Here 5 is totally arbitrary and is meant to take care of
        # situations where genlop -p says "2 minutes" and the countdown
        # later says "1 minute 55 seconds". Hopefully, it acts as a safety
        # net so that the user never gets a messy display.
        total_len=$(( $my_len + $len + ${#pkg_tmp} + 5 ))
    fi
    if [[ "$tmp" = *Emerging* ]]; then
        if [[ $total_len -lt $cols ]]; then
            tmp="$( genlop -nqc | sed -n '/ETA: /s/^[ ]*ETA:[ ]*//p' )"
            blen=$(( $cols - $my_len - $len - ${#tmp} ))
            [[ $blen -le 0 ]] && blen=1     # Just a safety check :-S
            infor "Emerging $cyan$pkg$normal. ETA:${BLANK:1:$blen}$tmp"
        elif [[ $(( $total_len - 14 )) -lt $cols ]]; then
            # We will print an even more simpler expression!!
            tmp="$( genlop -nqc | sed -n '/ETA: /s/^[ ]*ETA:[ ]*//p' )"
            blen=$(( $cols - $my_len + 14 - $len - ${#tmp} ))
            [[ $blen -le 0 ]] && blen=1     # Just a safety check :-S
            infor "$cyan$pkg$normal:${BLANK:1:$blen}$tmp"
        else
            infor "Emerging $cyan$pkg$normal."
        fi
    else
        infor "Installing $cyan$pkg$normal.$(tput el)"
    fi
    # Change the terminal title -- this is a constant fight with emerge!!
    # Hope the terminal doesn't mind! ;-)
    [[ "$DISPLAY" ]] && \
    echo -ne "\x1b]0;$(($_total_num - $_num + 1))/$_total_num: \
${pkg#*\/}, Total ETA: ${eta}\007"

    sleep $DELAY
done

# Either the emerge process is finished or there has been some
# error in the process
if LC_ALL="C" grep -qi "error.*$pkg fail" $TMPFILE || \
    tail -n 25 $TMPFILE | LC_ALL="C" grep -qiE "^\!\!\!.*(abort|error)"; then
    # This requires 2 more characters than earlier.
    blen=$(( $cols - $my_len - 2 - $len ))
    info "Emerging $cyan$pkg$normal.${BLANK:1:$blen}${red}Error!$normal "
    # Now check for packages which have been skipped.  This expression is
    # MASSIVE!!  This expression relies on the fact that emerge will not
    # fail on still another package within $DELAY seconds. So, it searches
    # for all --keep-going till the end of the file
    sed -n -e "/Failed.*${pkg%%\/*}\/${pkg##*\/}/,\$s/.*emerge --keep-going: \([^ ]*\) dropped.*/  $pink* Skipped  \1$normal due to --keep-going/p" $TMPFILE
    # Some error happened -- we will not use exit_prog; tmpfs data will
    # remain preserved then.
    die "Some error occured during emerge. 
    The last few lines of emerge are:\n$(tail -n 25 $TMPFILE)

    See $yellow$TMPFILE$normal for the full error message.
    "
elif [[ $exit_status -eq 1 ]]; then
    # The latest package emerged fine. Otherwise the error would be picked
    # up by the previous line.
    blen=$(( $cols - $my_len - 1 - $len ))
    info "Install  $cyan$pkg$normal.${BLANK:1:$blen}${green}Done!$normal "
    die "Some packages failed to emerge. See $yellow$TMPFILE$normal."
else
    # Looks like everything went fine :-/
    # Bug fix: check that $len is actually non-empty.
    if [[ "$len" ]]; then
        # This needs one more character than my_len
        blen=$(( $cols - $my_len - 1 - $len ))
        info "Install  $cyan$pkg$normal.${BLANK:1:$blen}${green}Done!$normal "
    fi
    # The emerge process is over. Now check for preserved rebuild notice
    tail $TMPFILE | LC_ALL="C" grep -qi "preserved" && \
    info "Preserved libraries found: See $yellow$TMPFILE$normal"

    # Update config files.
    if [[ "$TXT_UPDATER" || "$GUI_UPDATER" ]] && \
        tail $TMPFILE | LC_ALL="C" grep -qEi -m1 "config.*updat"; then
        centered_output dash " Updating config files "

        # Handle some error cases
        [[ "$TXT_UPDATER" && -z "$GUI_UPDATER" ]] && \
            GUI_UPDATER="$TXT_UPDATER"

        if [[ -n "$DISPLAY" ]]; then
                $GUI_UPDATER
        elif [[ "$TXT_UPDATER" ]]; then
                $TXT_UPDATER
        else
            Err "No config file updater was found. Check your settings in
    $yellow$config_dir/$config_file$normal\n"
        fi
    elif tail $TMPFILE | LC_ALL="C" grep -qEi -m1 "config.*updat"; then
        info "There are pending configuration updates:
$(tail $TMPFILE)

    See $yellow$TMPFILE$normal for more information.
    "
    fi
fi

exit_prog


# vim: set ai et fdm=marker ff=unix sta sts=4 sw=4 ts=4 tw=75 : 
